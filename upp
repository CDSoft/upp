#!/usr/bin/env lua

--[[
    This file is part of UPP.

    UPP is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    UPP is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with UPP.  If not, see <https://www.gnu.org/licenses/>.

    For further information about UPP you can visit
    http://cdelord.fr/upp
--]]

local help = [[
usage: upp [options] [files]

where 'files' is the list of files ('-' for 'stdin').

options:

    -h              show help
    -l script       execute a Lua script
    -e expression   execute a Lua expression
    -p path         add a path to package.path
    -o file         redirect the output to 'file'

Environment variables:

    UPP_PATH        paths to add to package.path
]]

local function id(x)
    return x
end

local function const(x)
    return function() return x end
end

local nop = const(nil)

local function map(f, xs)
    local ys = {}
    for _, x in ipairs(xs) do table.insert(ys, f(x)) end
    return ys
end

local function filter(p, xs)
    local ys = {}
    for _, x in ipairs(xs) do if p(x) then table.insert(ys, x) end end
    return ys
end

local function range(a, b, step)
    step = step or (a < b and 1) or (a > b and -1)
    local r = {}
    if a < b then
        assert(step > 0, "step shall be positive")
        while a <= b do
            table.insert(r, a)
            a = a + step
        end
    elseif a > b then
        assert(step < 0, "step shall be negative")
        while a >= b do
            table.insert(r, a)
            a = a + step
        end
    else
        table.insert(r, a)
    end
    return r
end

local function clone(xs)
    return map(id, xs)
end

local function die(msg, errcode)
    io.stderr:write("upp: "..msg.."\n")
    os.exit(errcode or 1)
end

local function add_package_path(env, path)
    local config = env.package.config:gmatch("[^\n]*")
    local dir_sep = config()
    local template_sep = config()
    local template = config()
    env.package.path = env.package.path..template_sep..path..dir_sep..template..".lua"
end

local function update_path(env, paths)
    if not paths then return end
    for path in paths:gmatch "[^:]*" do
        add_package_path(env, path)
    end
end

local function load_script(filename)
    return function(env)
        local path = assert(env.package.searchpath(filename:gsub("%.lua$", ""), env.package.path))
        assert(env.loadfile(path, "t", env))()
    end
end

local function eval_expr(expr)
    return function(env)
        assert(env.load(expr, expr, "t", env))()
    end
end

local outputs = {}
local output_file = nil

local function set_output(output)
    if output_file then die("multiple -o option") end
    output_file = output
    return nop
end

local function add_path(path)
    return function(env) add_package_path(env, path) end
end

local function process(name, content, env)
    table.insert(outputs, env.upp(content))
end

local function process_stdin()
    return function(env)
        local content = io.stdin:read "a"
        process("-", content, env)
    end
end

local function read_file(filename)
    local f = assert(io.open(filename))
    local content = f:read "a"
    f:close()
    return content
end

local function process_file(filename)
    return function(env)
        process(filename, read_file(filename), env)
    end
end

local function new_env()
    local env = {}
    local env_mt = {
        __index = {
            upp = function(content)
                local function format_value(x)
                    local x_mt = getmetatable(x)
                    if x_mt and x_mt.__tostring then return env.tostring(x) end
                    if type(x) == "table" then
                        -- each item of an array is a separate block of text
                        return table.concat(map(env.tostring, x), x.sep or env.BLOCK_SEP or "\n")
                    end
                    return env.tostring(x)
                end
                return (content:gsub("([$:])(%b())", function(t, x)
                    if t == "$" then -- x is an expression
                        local y = (assert(env.load("return "..x:sub(2, -2), x, "t", env)))()
                        -- if the expression can be evaluated, process it
                        return env.upp(format_value(y))
                    elseif t == ":" then -- x is a chunk
                        local y = (assert(env.load(x:sub(2, -2), x, "t", env)))()
                        -- if the chunk returns a value, process it
                        -- otherwise leave it blank
                        return y ~= nil and env.upp(format_value(y)) or ""
                    end
                end))
            end,
            die = die,
            import = function(name) load_script(name)(env) end,
            include = function(filename) return env.upp(read_file(filename)) end,
            when = function(cond) return cond and id or const "" end,
            map = map,
            filter = filter,
            range = range,
        },
    }
    for k, v in pairs(_G) do env_mt.__index[k] = v end
    env = setmetatable(env, env_mt)
    update_path(env, os.getenv "UPP_PATH")
    return env
end

local function parse_args()
    local args = clone(arg)
    local need_to_process_stdin = true
    local actions = {}
    local function shift(n) for i = 1,n do table.remove(args, 1) end end
    while #args > 0 do
        local action = nil
        if args[1] == "-h" then print(help); os.exit(0)
        elseif args[1] == "-l" then action = load_script(args[2]); shift(2)
        elseif args[1] == "-e" then action = eval_expr(args[2]); shift(2)
        elseif args[1] == "-o" then action = set_output(args[2]); shift(2)
        elseif args[1] == "-p" then action = add_path(args[2]); shift(2)
        elseif args[1] == "-" then action = process_stdin(); shift(1); need_to_process_stdin = false
        elseif args[1] == "--" then shift(1); break
        elseif args[1]:match "^%-" then die("Unknown option: "..args[1].."\n\n"..help)
        else action = process_file(args[1]); shift(1); need_to_process_stdin = false
        end
        table.insert(actions, action)
    end
    while #args > 0 do
        table.insert(actions, process_file(args[1])); shift(1); need_to_process_stdin = false
    end
    if need_to_process_stdin then table.insert(actions, process_stdin()) end
    return actions
end

local function process_args(actions)
    local env = new_env()
    for _, action in ipairs(actions) do action(env) end
    local f = output_file and assert(io.open(output_file, "w")) or io.stdout
    f:write(table.concat(outputs))
    f:close()
end

local function main()
    local actions = parse_args()
    process_args(actions)
end

main()
