#!/usr/bin/env lua

--[[
    This file is part of UPP.

    UPP is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    UPP is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with UPP.  If not, see <https://www.gnu.org/licenses/>.

    For further information about UPP you can visit
    http://cdelord.fr/upp
--]]

local help = [[
usage: upp [options] [files]

where 'files' is the list of files ('-' for 'stdin').

options:

    -h              show help
    -l script       execute a Lua script
    -e expression   execute a Lua expression
    -p path         add a path to package.path
    -o file         redirect the output to 'file'

Environment variables:

    UPP_PATH        paths to add to package.path
]]

local function id(x)
    return x
end

local function map(f, xs)
    local ys = {}
    for _, x in ipairs(xs) do table.insert(ys, f(x)) end
    return ys
end

local function clone(xs)
    return map(id, xs)
end

local function die(msg)
    io.stderr:write("upp: "..msg.."\n")
    os.exit(1)
end

local function add_package_path(env, path)
    local config = env.package.config:gmatch("[^\n]*")
    local dir_sep = config()
    local template_sep = config()
    local template = config()
    env.package.path = env.package.path..template_sep..path..dir_sep..template..".lua"
end

local function update_path(env, paths)
    if not paths then return end
    for path in paths:gmatch "[^:]*" do
        add_package_path(env, path)
    end
end

local function load_script(filename)
    return function(env)
        local path = assert(env.package.searchpath(filename:gsub("%.lua$", ""), env.package.path))
        assert(env.loadfile(path, "t", env))()
    end
end

local function eval_expr(expr)
    return function(env)
        assert(env.load(expr, expr, "t", env))()
    end
end

local outputs = {}
local output_file = nil

local function set_output(output)
    if output_file then die("multiple -o option") end
    output_file = output
    return function(env) end
end

local function add_path(path)
    return function(env) add_package_path(env, path) end
end

local function process(name, content, env)
    local output = env.upp(content)
    table.insert(outputs, output)
end

local function process_stdin()
    return function(env)
        local content = io.stdin:read "a"
        process("-", content, env)
    end
end

local function process_file(filename)
    return function(env)
        local f = assert(io.open(filename))
        local content = f:read "a"
        f:close()
        process(filename, content, env)
    end
end

local function new_env()
    local env = {}
    local env_mt = {
        __index = {
            upp = function(content)
                return (content:gsub("([$:])(%b())", function(t, x)
                    if t == "$" then -- x is an expression
                        local y = (assert(env.load("return "..x, x, "t", env)))()
                        -- if the expression can be evaluated, process it
                        -- otherwise leave it untouched
                        return y and env.upp(env.tostring(y))
                    elseif t == ":" then -- x is a chunk
                        local y = (assert(env.load(x:sub(2, -2), x, "t", env)))()
                        -- if the chunk returns a value, process it
                        -- otherwise leave it blank
                        return y and env.upp(env.tostring(y)) or ""
                    end
                end))
            end,
            import = function(name) load_script(name)(env) end,
            include = function(filename)
                local f = assert(io.open(filename))
                local content = f:read "a"
                f:close()
                return env.upp(content)
            end,
            when = function(cond)
                return function(what)
                    if cond then return what else return "" end
                end
            end,
        },
    }
    for k, v in pairs(_G) do env_mt.__index[k] = v end
    env = setmetatable(env, env_mt)
    update_path(env, os.getenv "UPP_PATH")
    return env
end

local function parse_args()
    local args = clone(arg)
    local need_to_process_stdin = true
    local actions = {}
    local function shift(n) for i = 1,n do table.remove(args, 1) end end
    while #args > 0 do
        local action = nil
        if args[1] == "-h" then print(help); os.exit(0)
        elseif args[1] == "-l" then action = load_script(args[2]); shift(2)
        elseif args[1] == "-e" then action = eval_expr(args[2]); shift(2)
        elseif args[1] == "-o" then action = set_output(args[2]); shift(2)
        elseif args[1] == "-p" then action = add_path(args[2]); shift(2)
        elseif args[1] == "-" then action = process_stdin(); shift(1); need_to_process_stdin = false
        elseif args[1] == "--" then shift(1); break
        elseif args[1]:match "^%-" then die("Unknown option: "..args[1].."\n\n"..help)
        else action = process_file(args[1]); shift(1); need_to_process_stdin = false
        end
        table.insert(actions, action)
    end
    while #args > 0 do
        table.insert(actions, process_file(args[1])); shift(1); need_to_process_stdin = false
    end
    if need_to_process_stdin then table.insert(actions, process_stdin()) end
    return actions
end

local function process_args(actions)
    local env = new_env()
    for _, action in ipairs(actions) do action(env) end
    local f = output_file and assert(io.open(output_file, "w")) or io.stdout
    f:write(table.concat(outputs))
    f:close()
end

local function main()
    local actions = parse_args()
    process_args(actions)
end

main()
